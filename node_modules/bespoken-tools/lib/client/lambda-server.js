"use strict";
const fs = require("fs");
const http = require("http");
const logging_helper_1 = require("../core/logging-helper");
const node_util_1 = require("../core/node-util");
let Logger = "BST-LAMBDA";
class LambdaServer {
    constructor(file, port, verbose) {
        this.file = file;
        this.port = port;
        this.verbose = verbose;
        this.server = null;
        this.dirty = false;
        this.lambda = null;
        this.watcher = null;
        this.requests = [];
        this.onDirty = null;
    }
    start(callback) {
        let self = this;
        let watchOptions = { "persistent": false, "recursive": true };
        this.watcher = fs.watch(process.cwd(), watchOptions, function (event, filename) {
            let exclude = false;
            if (filename.indexOf("node_modules") !== -1) {
                exclude = true;
            }
            else if (filename.endsWith("___")) {
                exclude = true;
            }
            else if (filename.startsWith(".")) {
                exclude = true;
            }
            if (!exclude) {
                logging_helper_1.LoggingHelper.info(Logger, "FS.Watch Event: " + event + ". File: " + filename + ". Reloading.");
                self.dirty = true;
                if (self.onDirty !== undefined && self.onDirty !== null) {
                    self.onDirty(filename);
                }
            }
        });
        this.server = http.createServer();
        this.server.listen(this.port);
        this.server.on("request", function (request, response) {
            self.requests.push(request);
            let requestBody = new Buffer("");
            request.on("data", function (chunk) {
                requestBody = Buffer.concat([requestBody, chunk]);
            });
            request.on("end", function () {
                if (request.method === "GET") {
                    return response.end("ALIVE");
                }
                else {
                    self.invoke(request, requestBody, response);
                }
            });
        });
        this.server.on("listening", function () {
            logging_helper_1.LoggingHelper.debug(Logger, "LambdaServer started on port: " + self.server.address().port.toString());
            if (callback !== undefined && callback !== null) {
                callback();
            }
        });
    }
    stop(onStop) {
        this.watcher.close();
        let request = null;
        for (request of this.requests) {
            try {
                request.socket.end();
            }
            catch (e) {
            }
        }
        this.server.close(function () {
            if (onStop !== undefined && onStop !== null) {
                onStop();
            }
        });
    }
    invoke(request, body, response) {
        let path = this.file;
        if (!path.startsWith("/")) {
            path = [process.cwd(), this.file].join("/");
        }
        logging_helper_1.LoggingHelper.debug(Logger, "Invoking Lambda: " + this.file);
        if (this.lambda === null || this.dirty) {
            this.lambda = node_util_1.NodeUtil.load(path);
            this.dirty = false;
        }
        const context = new LambdaContext(request, body, response, this.verbose);
        try {
            const bodyJSON = JSON.parse(body.toString());
            if (this.verbose) {
                console.log("Request:");
                console.log(JSON.stringify(bodyJSON, null, 2));
            }
            this.lambda.handler(bodyJSON, context, function (error, result) {
                context.done(error, result);
            });
        }
        catch (e) {
            context.fail(e);
        }
    }
}
exports.LambdaServer = LambdaServer;
class LambdaContext {
    constructor(request, body, response, verbose) {
        this.request = request;
        this.body = body;
        this.response = response;
        this.verbose = verbose;
        this.awsRequestId = "N/A";
        this.callbackWaitsForEmptyEventLoop = true;
        this.functionName = "BST.LambdaServer";
        this.functionVersion = "N/A";
        this.memoryLimitInMB = -1;
        this.invokedFunctionArn = "N/A";
        this.logGroupName = "N/A";
        this.logStreamName = null;
        this.identity = null;
        this.clientContext = null;
    }
    fail(error) {
        this.done(error, null);
    }
    succeed(body) {
        this.done(null, body);
    }
    getRemainingTimeMillis() {
        return -1;
    }
    done(error, body) {
        let statusCode = 200;
        let contentType = "application/json";
        let bodyString = null;
        if (error === null) {
            bodyString = JSON.stringify(body);
            if (this.verbose) {
                console.log("Response:");
                console.log(JSON.stringify(body, null, 2));
            }
        }
        else {
            statusCode = 500;
            contentType = "text/plain";
            bodyString = error.toString();
        }
        this.response.writeHead(statusCode, {
            "Content-Type": contentType
        });
        this.response.end(new Buffer(bodyString));
    }
}
//# sourceMappingURL=lambda-server.js.map